import * as vscode from 'vscode';

export interface DetectorEvents {
  onStart: (callback: () => void) => void;
  onPartial: (callback: () => void) => void;
  onDone: (callback: () => void) => void;
  onError: (callback: () => void) => void;
}

interface AIActivityState {
  isActive: boolean;
  lastActivity: number;
  editCount: number;
  rapidEdits: number;
  lastEditTime: number;
  timeoutId?: ReturnType<typeof setTimeout>;
}

export function createDetector(): DetectorEvents {
  const callbacks = {
    start: [] as (() => void)[],
    partial: [] as (() => void)[],
    done: [] as (() => void)[],
    error: [] as (() => void)[]
  };

  const state: AIActivityState = {
    isActive: false,
    lastActivity: 0,
    editCount: 0,
    rapidEdits: 0,
    lastEditTime: 0
  };

  // Configuration for AI detection
  const AI_DETECTION_CONFIG = {
    RAPID_EDIT_THRESHOLD: 3, // edits within this many seconds
    RAPID_EDIT_WINDOW: 2000, // milliseconds
    AI_SESSION_TIMEOUT: 10000, // milliseconds of inactivity before considering AI done
    MIN_EDITS_FOR_AI: 2, // minimum edits to consider as AI activity
    DEBOUNCE_DELAY: 500 // milliseconds to debounce rapid events
  };

  function triggerStart() {
    if (state.isActive) return;
    state.isActive = true;
    state.lastActivity = Date.now();
    console.log('Chibi Copilot: AI activity detected - START');
    callbacks.start.forEach(cb => cb());
  }

  function triggerPartial() {
    if (!state.isActive) return;
    state.lastActivity = Date.now();
    console.log('Chibi Copilot: AI activity detected - PARTIAL');
    callbacks.partial.forEach(cb => cb());
  }

  function triggerDone() {
    if (!state.isActive) return;
    state.isActive = false;
    state.editCount = 0;
    state.rapidEdits = 0;
    console.log('Chibi Copilot: AI activity detected - DONE');
    callbacks.done.forEach(cb => cb());
  }

  function triggerError() {
    state.isActive = false;
    state.editCount = 0;
    state.rapidEdits = 0;
    console.log('Chibi Copilot: AI activity detected - ERROR');
    callbacks.error.forEach(cb => cb());
  }

  function resetAITimeout() {
    if (state.timeoutId) {
      clearTimeout(state.timeoutId);
    }
    state.timeoutId = setTimeout(() => {
      if (state.isActive) {
        triggerDone();
      }
    }, AI_DETECTION_CONFIG.AI_SESSION_TIMEOUT);
  }

  function detectRapidEdits(): boolean {
    const now = Date.now();
    const timeSinceLastEdit = now - state.lastEditTime;
    
    if (timeSinceLastEdit < AI_DETECTION_CONFIG.RAPID_EDIT_WINDOW) {
      state.rapidEdits++;
    } else {
      state.rapidEdits = 1;
    }
    
    state.lastEditTime = now;
    return state.rapidEdits >= AI_DETECTION_CONFIG.RAPID_EDIT_THRESHOLD;
  }

  function handleDocumentChange(event: vscode.TextDocumentChangeEvent) {
    // Skip if it's not a text document or if changes are too small
    if (event.document.uri.scheme !== 'file' && event.document.uri.scheme !== 'untitled') {
      return;
    }

    // Count significant changes (not just cursor movements)
    const significantChanges = event.contentChanges.filter(change => 
      change.text.length > 0 || change.rangeLength > 0
    );

    if (significantChanges.length === 0) return;

    state.editCount += significantChanges.length;
    const isRapidEdit = detectRapidEdits();

    // Detect AI activity patterns
    if (!state.isActive && (state.editCount >= AI_DETECTION_CONFIG.MIN_EDITS_FOR_AI || isRapidEdit)) {
      triggerStart();
    } else if (state.isActive) {
      triggerPartial();
    }

    resetAITimeout();
  }

  // Monitor for specific AI patterns in text changes
  function detectAIPatterns(text: string): boolean {
    // Common AI-generated code patterns
    const aiPatterns = [
      /\/\/ AI generated|AI generated|Generated by AI/i,
      /\/\/ TODO: |\/\/ FIXME: |\/\/ NOTE: /i,
      /console\.log\(/g,
      /\/\*[\s\S]*?\*\//g, // Large comment blocks
      /function\s+\w+\s*\([^)]*\)\s*{[\s\S]{50,}/, // Large function blocks
      /class\s+\w+[\s\S]{50,}/, // Large class definitions
      /import\s+.*from\s+['"]/g, // Multiple imports
      /const\s+\w+\s*=\s*\([^)]*\)\s*=>/g, // Arrow functions
    ];

    return aiPatterns.some(pattern => pattern.test(text));
  }

  // Enhanced document change handler with AI pattern detection
  const enhancedHandleDocumentChange = (event: vscode.TextDocumentChangeEvent) => {
    // Call original handler
    handleDocumentChange(event);

    // Additional AI pattern detection
    if (event.contentChanges.length > 0) {
      const allText = event.contentChanges.map(change => change.text).join('');
      if (detectAIPatterns(allText) && !state.isActive) {
        console.log('Chibi Copilot: AI patterns detected in text changes');
        triggerStart();
        resetAITimeout();
      }
    }
  };

  function handleSelectionChange(event: vscode.TextEditorSelectionChangeEvent) {
    // AI often makes rapid selections or moves cursor quickly
    if (state.isActive) {
      state.lastActivity = Date.now();
      triggerPartial();
    }
  }

  function handleActiveEditorChange(editor: vscode.TextEditor | undefined) {
    // AI might switch between files rapidly
    if (editor && state.isActive) {
      state.lastActivity = Date.now();
      triggerPartial();
    }
  }

  function handleDocumentSave(event: vscode.TextDocument) {
    // AI often saves frequently during generation
    if (state.isActive) {
      state.lastActivity = Date.now();
      triggerPartial();
    }
  }

  // Set up event listeners
  const subscriptions: vscode.Disposable[] = [];

  // Monitor document changes (main AI detection)
  subscriptions.push(
    vscode.workspace.onDidChangeTextDocument(enhancedHandleDocumentChange)
  );

  // Monitor selection changes (cursor movement patterns)
  subscriptions.push(
    vscode.window.onDidChangeTextEditorSelection(handleSelectionChange)
  );

  // Monitor active editor changes (file switching)
  subscriptions.push(
    vscode.window.onDidChangeActiveTextEditor(handleActiveEditorChange)
  );

  // Monitor document saves
  subscriptions.push(
    vscode.workspace.onDidSaveTextDocument(handleDocumentSave)
  );

  // Monitor for errors in the output panel (AI errors)
  subscriptions.push(
    vscode.workspace.onDidOpenTextDocument(doc => {
      if (doc.uri.scheme === 'output' && doc.uri.path.includes('extension-output')) {
        // This might indicate an AI extension error
        setTimeout(() => {
          if (state.isActive) {
            triggerError();
          }
        }, 1000);
      }
    })
  );

  // Monitor for AI-related commands being executed
  subscriptions.push(
    vscode.commands.registerCommand('chibiCopilot.detectAICommand', () => {
      if (!state.isActive) {
        triggerStart();
      } else {
        triggerPartial();
      }
      resetAITimeout();
    })
  );

  // Cleanup function
  const cleanup = () => {
    subscriptions.forEach(sub => sub.dispose());
    if (state.timeoutId) {
      clearTimeout(state.timeoutId);
    }
  };

  // Store cleanup for potential future use
  (createDetector as any).cleanup = cleanup;
  
  return {
    onStart: (callback: () => void) => callbacks.start.push(callback),
    onPartial: (callback: () => void) => callbacks.partial.push(callback),
    onDone: (callback: () => void) => callbacks.done.push(callback),
    onError: (callback: () => void) => callbacks.error.push(callback)
  };
}
